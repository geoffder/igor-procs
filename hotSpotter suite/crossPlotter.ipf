#pragma rtGlobals=3		// Use modern global access method and strict wave access.
#include <FilterDialog> menus=0
#include <All IP Procedures>
#include <Image Saver>
Function crossPlotter(prefix, mode, mask)
	String prefix
	Variable mode, mask
	
	//this function is made to be run following execution of hotSpotterDS() on multiple trials
	//prefix = wave prefix in quotes ("dir")
	//mode = 0: dFs for all directions; 1: thetaMatrices; 2:relThetaMatrices; 3: DSiMatrices
	//mask = 0: use multiMatrix for the first trial; 1: create new mask using multiMatrices from all trials (ideally just use 0)
	
	Variable i, j, xPos1, yPos1, xPos2, yPos2, xWidth, yHeight, waveNum, trialNum, maskThreshold, first, yesNaN
	Make/O angle = {90, 270, 180, 0, 135, 315, 225, 45} //order and direction of light stimulation
	
	String roiName, winTitle, ROIfolder
	Variable importROIs, numROIs
	
	Prompt importROIs, "Import ROIs? (0 or 1): "
	Prompt numROIs, "Number of ROIs: "
	DoPrompt "Enter parameters", importROIs, numROIs
	
	Print "Number of ROIs: " + num2str(numROIs)
	
	if(!importROIs)
		for(j =1; j <= numROIs; j += 1) //start with differROI1
			roiName = "crossROI" + num2str(j) 
			
			print "Draw crossPlotter ROI ..." + num2str(j) 
		
			GetWindow kwTopWin wtitle //get window title for active graph
			winTitle = S_value
			
			//Create continue button window and place it next to the active graph
			NewPanel /K=2 /W=(187,368,437,531) as "Pause for Cursor"
			DoWindow/C PauseForROI //Name the continue button window
			AutoPositionWindow/E/M=1/R=$("Graph" + num2str(str2num(winTitle[5,7])))
			
			//Draw text and button on Continue window
			DrawText 21,20,"Draw ROI" + num2str(j) + ", then" 
			DrawText 21,40,"Click Continue."
			Button button0,pos={80,58},size={92,20},title="Continue" //make button
			Button button0,proc=PauseForROI_ContButtonProc //point button to procedure that kills the window

			GraphWaveDraw/F=3/O/L/T $(roiName + "_y"), $(roiName + "_x")
			PauseForUser PauseForROI, $("Graph" + num2str(str2num(winTitle[5,7]))) //needs to be just Graph# part of title
			GraphNormal //end draw mode and return graph to normal
		endfor
	elseif(importROIs)
		Prompt ROIfolder, "Folder with ROIs to import: "
		DoPrompt "Leave blank if in current folder", ROIfolder
		
		if(!stringmatch(ROIfolder, "")) //if not in current folder
			for(j = 1; j <= numROIs; j += 1)
				WAVE ROI = $("root:" + ROIfolder + ":crossROI" + num2str(j) + "_y")
				Duplicate/O ROI $("crossROI" + num2str(j) + "_y")
				WAVE ROI = $("root:" + ROIfolder + ":crossROI" + num2str(j) + "_x")
				Duplicate/O ROI $("crossROI" + num2str(j) + "_x")
			endfor
		endif
	endif
	
	//point to the trials wave in this folder generated by hotSpotterDS()
	WAVE trials = $(GetDataFolder(1) + "trials")
	
	//This is the default (mask != 1). Use the multiMatrix from the first trial as the mask.
	WAVE  multiMatrix = $(GetDataFolder(1) + "multiMatrix_" + num2str(trials[0]))
	
	//increasing this to cut down on pixels that do not have signal in all trials
	maskThreshold = 1e+15; //Should correspond to (multi)threshold used in hotSpotter() (1e+15)
	
	xWidth = DimSize(multiMatrix, 0) //DimSize returns the size of each dimension (x, y, z) 
	yHeight = DimSize(multiMatrix, 1)
	
	//When activated, this option will create a new multiMatrix mask using the multis from all trials
	//Then threshold is set even higher to only include those pixels that are bright across all trials.
	//Not really great to have to use though, since non-overlapping masks mean the same pixels do not
	//represent the same points on the dendrite any longer. Included in function anyway as an option.
	if(mask == 1)
		Duplicate/O multiMatrix newMask  //already multiMatrix of first trial
		for(i = 1; i < numpnts(trials); i+=1) //therefore start at i =1 for the second trial 
			WAVE  multiMatrix = $(GetDataFolder(1) + "multiMatrix_" + num2str(trials[i]))
			MatrixOp/O newMask = multiMatrix * newMask
		endfor
		//point multiMatrix global link to the new combo mask
		WAVE  multiMatrix = $(GetDataFolder(1) + "newMask") 
		maskThreshold = 1e+30 //placeholder number, not tested
	endif
	
	//Will need to access this for results of Pearson correlation
	wave W_StatsLinearCorrelationTest
	
	first = 1
	yesNaN = 0
	
	//switch-case block to divide up code for correlating different values
	//behaves similarly to a set of if-elseif statements
	switch(mode)
		//correlations of dF across trials for each direction
		case 0:
			//Point to correct X and Y roi waves (define hand-drawn ROI)
			WAVE roiY = $(GetDataFolder(1) + "crossROI" + num2str(1) + "_y")
			WAVE roiX = $(GetDataFolder(1) + "crossROI" + num2str(1) + "_x")
			
			WAVE Matrix = $(GetDataFolder(1) + "multiMatrix_" + num2str(trials[0])) //same dimensions, no problem
			//Convert drawn "waves" into a mask
			ImageBoundaryToMask ywave=roiY,xwave=roiX,width=(xWidth),height=(yHeight),scalingwave=Matrix,seedx=(dimOffset(Matrix,0)+dimDelta(Matrix,0)),seedy=(dimOffset(Matrix,1)+dimDelta(Matrix,1))
			WAVE ROIMask = $(GetDataFolder(1) + "M_ROIMask")
		
			for(i = 0; i < numpnts(angle); i += 1) //for each direction
				Make/O/N=(xWidth,yHeight) $("avgDF_" + prefix + num2str(i))
				WAVE avgMatrix = $(GetDataFolder(1) +"avgDF_" + prefix + num2str(i))
				
				//Make/O/N=(xWidth,yHeight,numpnts(trials)) $("resDF_" + prefix + num2str(i))
				//WAVE resMatrix = $(GetDataFolder(1) + "resDF_" + prefix + num2str(i))
				
				Make/O/N=(xWidth,yHeight,numpnts(trials)) $("stackDF_" + prefix + num2str(i))
				WAVE stackMatrix = $(GetDataFolder(1) + "stackDF_" + prefix + num2str(i))
				
				Make/O/N=1 $("dF_rWave_" + prefix + num2str(i))
				WAVE rWave = $(GetDataFolder(1) + "dF_rWave_" + prefix + num2str(i))
				
				Make/O/N=1 $("dF_distWave_" + prefix + num2str(i))
				WAVE distWave = $(GetDataFolder(1) + "dF_distWave_" + prefix + num2str(i))
				
				//Comment out all of this residual matrix stuff for now, 
				//and replace it with a dF trial stack to use instead.
				for(j = 0; j < numpnts(trials); j += 1) //create an avg dF matrix for current direction
					WAVE Matrix = $(GetDataFolder(1) + "dF_" + prefix + num2str(i) + "_" + num2str(trials[j]))
					MatrixOP/O avgMatrix = avgMatrix + Matrix
				endfor
				avgMatrix /= numpnts(trials)
				
				for(j = 0; j < numpnts(trials); j += 1) //loop through again to subtract each trial from calculated mean 
					WAVE Matrix = $(GetDataFolder(1) + "dF_" + prefix + num2str(i) + "_" + num2str(trials[j]))
					///MatrixOP/O resMatrixTemp = avgMatrix - Matrix //2D residual matrix for current trial
					//resMatrix[][][j] = resMatrixTemp[p][q] //insert into stack of residuals for all trials (p and q indicate all x and y)
					stackMatrix[][][j] = Matrix[p][q] //assemble dFs of all trials in to a 3D matrix (stack)
				endfor
				
				//Now there is a 3D matrix of residuals of all trials for current direction (image in [x][y], trials in [z]) 
				for (yPos1 = 0; yPos1 < yHeight; yPos1 += 1)
					for(xPos1 = 0; xPos1 < xWidth; xPos1 += 1)
						//if block to ensure these operations only occur on pixels that pass threshold
						if (multiMatrix[xPos1][yPos1]  > maskThreshold && ROIMask[xPos1][yPos1] == 0)
							MatrixOp/O zWave1 = beam(stackMatrix, xPos1, yPos1)   //Create a zWave for current pixel for all trials
							
							for (yPos2 = yPos1; yPos2 < yHeight; yPos2 += 1)
								for(xPos2 = xPos1+1; xPos2 < xWidth; xPos2 += 1)
									if (multiMatrix[xPos2][yPos2]  > maskThreshold && ROIMask[xPos2][yPos2] == 0)
										MatrixOp/O zWave2 = beam(stackMatrix, xPos2, yPos2)
										//Calculate Pearson r. /Q suppresses console output.
										//Results found in W_StatsLinearCorrelationTest. r is index [1].
										StatsLinearCorrelationTest/Q zWave1, zWave2
										
										if (first == 1)
											//rWave[0] = StatsCorrelation(zWave1, zWave2)
											rWave[0] = {W_StatsLinearCorrelationTest[1]}
											//Calculate distance between the two points being correlated
											distWave[0] = sqrt((xPos2 - xPos1)^2 + (yPos2 - yPos1)^2)
											first = 0
										else
											//rWave[numpnts(rWave)] = {StatsCorrelation(zWave1, zWave2)}
											rWave[numpnts(rWave)] = {W_StatsLinearCorrelationTest[1]}
											distWave[numpnts(distWave)] = {sqrt((xPos2 - xPos1)^2 + (yPos2 - yPos1)^2)}
										endif
									endif //no else, just skip this position
								endfor
							endfor
						endif //no else, just skip this position
					endfor //end of x loop 1
				endfor //end of y loop 1
				
				
			endfor //end of direction loop
			
		break
		
		//correlations of preferred angles (theta) of each pixel across trials
		case 1:
			Make/O/N=(xWidth,yHeight,numpnts(trials)) $("stackTheta_" + prefix)
			WAVE stackMatrix = $(GetDataFolder(1) + "stackTheta_" + prefix)
				
			Make/O/N=1 $("theta_rWave_" + prefix)
			WAVE rWave = $(GetDataFolder(1) + "theta_rWave_" + prefix)
				
			Make/O/N=1 $("theta_distWave_" + prefix)
			WAVE distWave = $(GetDataFolder(1) + "theta_distWave_" + prefix)
				
			for(j = 0; j < numpnts(trials); j += 1)
				WAVE Matrix = $(GetDataFolder(1) + "thetaMatrix_" + num2str(trials[j]))
				stackMatrix[][][j] = Matrix[p][q] //assemble thetas of all trials in to a 3D matrix (stack)
			endfor
			
			//Now there is a 3D matrix of thetas for all trials (image in [x][y], trials in [z]) 
				for (yPos1 = 0; yPos1 < yHeight; yPos1 += 1)
					for(xPos1 = 0; xPos1 < xWidth; xPos1 += 1)
						//if block to ensure these operations only occur on pixels that pass threshold
						if (multiMatrix[xPos1][yPos1]  > maskThreshold)
							MatrixOp/O zWave1 = beam(stackMatrix, xPos1, yPos1)   //Create a zWave for current pixel for all trials
							
							for (yPos2 = yPos1; yPos2 < yHeight; yPos2 += 1)
								for(xPos2 = xPos1+1; xPos2 < xWidth; xPos2 += 1)
									if (multiMatrix[xPos2][yPos2]  > maskThreshold)
										MatrixOp/O zWave2 = beam(stackMatrix, xPos2, yPos2)
										//Calculate Pearson r. /Q suppresses console output.
										//Results found in W_StatsLinearCorrelationTest. r is index [1].
										StatsLinearCorrelationTest/Q zWave1, zWave2
										
										if (first == 1)
											//rWave[0] = StatsCorrelation(zWave1, zWave2)
											rWave[0] = {W_StatsLinearCorrelationTest[1]}
											//Calculate distance between the two points being correlated
											distWave[0] = sqrt((xPos2 - xPos1)^2 + (yPos2 - yPos1)^2)
											first = 0
										else
											//rWave[numpnts(rWave)] = {StatsCorrelation(zWave1, zWave2)}
											rWave[numpnts(rWave)] = {W_StatsLinearCorrelationTest[1]}
											distWave[numpnts(distWave)] = {sqrt((xPos2 - xPos1)^2 + (yPos2 - yPos1)^2)}
										endif
									endif //no else, just skip this position
								endfor
							endfor
						endif //no else, just skip this position
					endfor //end of x loop 1
				endfor //end of y loop 1
			
		break
		
		//correlations of absolute relative (to preferred spiking direction of cell) preferred angles (theta) of each pixel across trials
		case 2:
			Make/O/N=(xWidth,yHeight,numpnts(trials)) $("stackRelThetaAbs_" + prefix)
			WAVE stackMatrix = $(GetDataFolder(1) + "stackRelThetaAbs_" + prefix)
				
			Make/O/N=1 $("relThetaAbs_rWave_" + prefix)
			WAVE rWave = $(GetDataFolder(1) + "relThetaAbs_rWave_" + prefix)
				
			Make/O/N=1 $("relThetaAbs_distWave_" + prefix)
			WAVE distWave = $(GetDataFolder(1) + "relThetaAbs_distWave_" + prefix)
				
			for(j = 0; j < numpnts(trials); j += 1)
				WAVE Matrix = $(GetDataFolder(1) + "relThetaMatrixAbs_" + num2str(trials[j]))
				stackMatrix[][][j] = Matrix[p][q] //assemble thetas of all trials in to a 3D matrix (stack)
			endfor
			
			//Now there is a 3D matrix of thetas for all trials (image in [x][y], trials in [z]) 
			for (yPos1 = 0; yPos1 < yHeight; yPos1 += 1)
				yesNaN = 0
				for(xPos1 = 0; xPos1 < xWidth; xPos1 += 1)
					yesNaN = 0
					//if block to ensure these operations only occur on pixels that pass threshold
					if (multiMatrix[xPos1][yPos1]  > maskThreshold)
						MatrixOp/O zWave1 = beam(stackMatrix, xPos1, yPos1)   //Create a zWave for current pixel for all trials
						for(j = 0; j < numpnts(trials); j += 1)
							if (yesNan != 1)
								if (numtype(zWave1[j]) == 2)
									yesNaN = 1
								endif
							endif
						endfor
						if(yesNaN == 1)
							yesNaN = 0
							continue
						endif
						for (yPos2 = yPos1; yPos2 < yHeight; yPos2 += 1)
							yesNaN = 0
							for(xPos2 = xPos1+1; xPos2 < xWidth; xPos2 += 1)
								yesNaN = 0
								if (multiMatrix[xPos2][yPos2]  > maskThreshold)
									MatrixOp/O zWave2 = beam(stackMatrix, xPos2, yPos2)
									for(j = 0; j < numpnts(trials); j += 1)
										if (yesNan != 1)
											if (numtype(zWave2[j]) == 2)
												yesNaN = 1
											endif
										endif
									endfor
									if(yesNaN == 1)
										yesNaN = 0
										continue
									endif
									//Calculate Pearson r. /Q suppresses console output.
									//Results found in W_StatsLinearCorrelationTest. r is index [1].
									StatsLinearCorrelationTest/Q zWave1, zWave2
										
									if (first == 1)
										//rWave[0] = StatsCorrelation(zWave1, zWave2)
										rWave[0] = {W_StatsLinearCorrelationTest[1]}
										//Calculate distance between the two points being correlated
										distWave[0] = sqrt((xPos2 - xPos1)^2 + (yPos2 - yPos1)^2)
										first = 0
									else
										//rWave[numpnts(rWave)] = {StatsCorrelation(zWave1, zWave2)}
										rWave[numpnts(rWave)] = {W_StatsLinearCorrelationTest[1]}
										distWave[numpnts(distWave)] = {sqrt((xPos2 - xPos1)^2 + (yPos2 - yPos1)^2)}
									endif
								endif //no else, just skip this position
							endfor
						endfor
					endif //no else, just skip this position
				endfor //end of x loop 1
			endfor //end of y loop 1
			
		break
		
		//correlations of DSi values (strength of theta vector) of each pixel across trials	
		case 3:
			Make/O/N=(xWidth,yHeight,numpnts(trials)) $("stackDSi_" + prefix)
			WAVE stackMatrix = $(GetDataFolder(1) + "stackDSi_" + prefix)
			
			Make/O/N=1 $("DSi_rWave_" + prefix)
			WAVE rWave = $(GetDataFolder(1) + "DSi_rWave_" + prefix)
				
			Make/O/N=1 $("DSi_distWave_" + prefix)
			WAVE distWave = $(GetDataFolder(1) + "DSi_distWave_" + prefix)
				
			for(j = 0; j < numpnts(trials); j += 1)
				WAVE Matrix = $(GetDataFolder(1) + "DSiMatrix_" + num2str(trials[j]))
				stackMatrix[][][j] = Matrix[p][q] //assemble thetas of all trials in to a 3D matrix (stack)
			endfor
			
			//Now there is a 3D matrix of thetas for all trials (image in [x][y], trials in [z]) 
			for (yPos1 = 0; yPos1 < yHeight; yPos1 += 1)
				for(xPos1 = 0; xPos1 < xWidth; xPos1 += 1)
					//if block to ensure these operations only occur on pixels that pass threshold
					if (multiMatrix[xPos1][yPos1]  > maskThreshold)
						MatrixOp/O zWave1 = beam(stackMatrix, xPos1, yPos1)   //Create a zWave for current pixel for all trials
						
						for (yPos2 = yPos1; yPos2 < yHeight; yPos2 += 1)
							for(xPos2 = xPos1+1; xPos2 < xWidth; xPos2 += 1)
								if (multiMatrix[xPos2][yPos2]  > maskThreshold)
									MatrixOp/O zWave2 = beam(stackMatrix, xPos2, yPos2)
									//Calculate Pearson r. /Q suppresses console output.
									//Results found in W_StatsLinearCorrelationTest. r is index [1].
									StatsLinearCorrelationTest/Q zWave1, zWave2
									
									if (first == 1)
										//rWave[0] = StatsCorrelation(zWave1, zWave2) //non-pearson r, not as good but works and is fast
										rWave[0] = {W_StatsLinearCorrelationTest[1]}
										//Calculate distance between the two points being correlated
										distWave[0] = sqrt((xPos2 - xPos1)^2 + (yPos2 - yPos1)^2)
										first = 0
									else
										//rWave[numpnts(rWave)] = {StatsCorrelation(zWave1, zWave2)}
										rWave[numpnts(rWave)] = {W_StatsLinearCorrelationTest[1]}
										distWave[numpnts(distWave)] = {sqrt((xPos2 - xPos1)^2 + (yPos2 - yPos1)^2)}
									endif
								endif //no else, just skip this position
							endfor
						endfor
					endif //no else, just skip this position
				endfor //end of x loop 1
			endfor //end of y loop 1
		break
			
		default:
			print("Please select a mode: ")
			print("0: dFs for all directions; 1: thetaMatrices; 2:relThetaMatrices; 3: DSiMatrices")
		break
	
	endswitch
			
end